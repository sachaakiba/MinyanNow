// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
}

// Statut de vérification des documents par un superAdmin
enum DocumentVerificationStatus {
  PENDING // En attente de vérification
  APPROVED // Approuvé par un superAdmin
  REJECTED // Rejeté par un superAdmin
}

// Rôle utilisateur
enum UserRole {
  USER // Utilisateur standard
  SUPER_ADMIN // Peut valider les documents
}

// Better Auth models
model User {
  id                  String   @id @default(cuid())
  name                String?
  email               String   @unique
  emailVerified       Boolean  @default(false)
  phoneNumber         String?  @unique
  phoneNumberVerified Boolean  @default(false)
  image               String?
  pushToken           String? // Expo push notification token
  language            String   @default("fr") // Langue préférée (fr, en, he)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Rôle utilisateur (USER par défaut, SUPER_ADMIN pour valider les documents)
  role UserRole @default(USER)

  // Informations de profil
  firstName         String? // Prénom
  lastName          String? // Nom de famille
  hebrewName        String? // Prénom hébraïque (ex: Moshe ben Avraham)
  dateOfBirth       DateTime? // Date de naissance
  barMitzvahParasha String? // Paracha de la Bar Mitzvah
  synagogue         String? // Synagogue fréquentée
  community         String? // Communauté (Ashkénaze, Séfarade, etc.)
  profileCompleted  Boolean   @default(false) // Profil complété

  // Vérification d'identité - Pièce d'identité
  idDocumentUrl          String? // URL Cloudinary de la pièce d'identité
  idDocumentId           String? // ID public Cloudinary pour suppression
  idDocumentResourceType String?   @default("image") // Type de ressource Cloudinary (image ou raw pour PDF)
  idUploadedAt           DateTime? // Date d'upload de la pièce d'identité

  // Vérification d'identité - Ketouba (certificat de mariage)
  ketoubaDocumentUrl          String? // URL Cloudinary de la Ketouba
  ketoubaDocumentId           String? // ID public Cloudinary pour suppression
  ketoubaDocumentResourceType String?   @default("image") // Type de ressource Cloudinary (image ou raw pour PDF)
  ketoubaUploadedAt           DateTime? // Date d'upload de la Ketouba

  // Vérification d'identité - Selfie (photo de la personne)
  selfieDocumentUrl          String? // URL Cloudinary du selfie
  selfieDocumentId           String? // ID public Cloudinary pour suppression
  selfieDocumentResourceType String?   @default("image") // Type de ressource Cloudinary (image ou raw pour PDF)
  selfieUploadedAt           DateTime? // Date d'upload du selfie

  // Préférences de notifications
  notificationsEnabled Boolean   @default(true) // Master toggle
  notifyProximity      Boolean   @default(true) // Notif quand proche d'un événement
  notifyNewRequests    Boolean   @default(true) // Notif nouvelle demande (organisateur)
  notifyRequestStatus  Boolean   @default(true) // Notif accepté/refusé (participant)
  notifyEventUpdates   Boolean   @default(true) // Notif modification événement
  notifyEventReminders Boolean   @default(true) // Rappels avant événement
  proximityRadius      Int       @default(500) // Rayon de proximité en mètres (100-2000)
  lastKnownLatitude    Float? // Dernière position connue
  lastKnownLongitude   Float? // Dernière position connue
  lastLocationUpdate   DateTime? // Date dernière mise à jour position

  sessions      Session[]
  accounts      Account[]
  events        Event[]
  eventRequests EventRequest[]

  @@map("users")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("accounts")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verifications")
}

// Event Types:
// SHEVA_BERAKHOT - Semaine après le mariage (7 jours de bénédictions)
// BRIT_MILA - Circoncision
// MINCHA - Prière de l'après-midi
// ARVIT - Prière du soir (aussi appelée Maariv)
// OTHER - Autre événement religieux

enum EventType {
  SHEVA_BERAKHOT
  BRIT_MILA
  MINCHA
  ARVIT
  OTHER
}

enum EventRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model Event {
  id            String    @id @default(cuid())
  title         String
  description   String?
  type          EventType
  date          DateTime
  endDate       DateTime?
  deadlineHours Int? // Nombre d'heures avant l'événement pour la date limite d'inscription (ex: 1 = 1h avant)

  // Location
  address   String
  city      String
  latitude  Float
  longitude Float

  // Capacity - maxParticipants = nombre total nécessaire (ex: 10 pour un minyan)
  maxParticipants Int @default(10)

  // Participants initiaux (noms des personnes déjà présentes, JSON array)
  initialParticipants String[] @default([])

  // Relations
  organizerId String
  organizer   User   @relation(fields: [organizerId], references: [id], onDelete: Cascade)

  requests EventRequest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("events")
}

model EventRequest {
  id      String             @id @default(cuid())
  status  EventRequestStatus @default(PENDING)
  message String?

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, userId])
  @@map("event_requests")
}
